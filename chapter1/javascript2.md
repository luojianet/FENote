# 表达式和运算符
* 表达式JavaScript中的一个短语，Javascript解释器会将其计算(evaluate)出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单的表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的。比如，数组访问表达式是由一个表示数组的表达式、左括号、一个整数表达式和右括号构成。他们所组成的新的表达式的运算结果是该数组的特定位置的元素值。同样的，函数调用表达式由一个表示函数对象的表达式和0个参数表达式构成。
* 最简单的表达式是“原始表达式(Primary expression)”。原始表达式是表达式的最小单位--他们不再包含其它表达式。Javascript中的原始表达式包含常量直接量、关键字和变量。
* 对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化表达式有时称做“对象直接量”和“数组直接量”。然而和布尔直接量不同，他们不是原始表达式，因为他们所包含的成员或者元素都是子表达式。
* 数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为undefined的元素。
* 函数定义表达式定义一个javascript函数。表达式的值是这个新定义的函数。`var square=function(x){return x*x}`
* 属性访问表达式运算得到一个对象属性或一个数组元素的值。`expression.identifier`和`expression[expression]`
* 不管使用哪种形式的属性访问表达式，在"."和"["之前的表达式总是会首先计算。如果计算结果是null或者undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。
* javascript中的调用表达式(invocation expression)是一种调用(或者执行)函数或方法的语法表示。
* 任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一个属性访问表达式，那么这个调用称做“方法调用(method invocation)”。
* 对象创建表达式(object creation expression)创建一个对象调用一个函数(这个函数称做构造函数)初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new。
* 如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的。`new Object`,`new Date`
* 运算符可以根据其操作数的个数进行分类。JavaScript中的大多数运算符是一个二元运算符(binary operator)，将两个表达式合并成一个稍复杂的表达式。换言之，它们的操作数均是两个。JavaScript同样支持一些一元运算符(unary operator)，它们将一个表达式转换为另一个稍复杂的表达式。表达式-x中的‘-’运算符就是一个一元运算符，是将操作数x求负值。最后，javascript支持一个三元运算符(ternary operator)，条件判断运算符“？：”，它将三个表达式合并成一个表达式。
* Javascript运算符通常会根据需要对操作数进行类型转换。乘法运算符“*”希望操作数为数字，但表达式“3”*“5”却是合法的，因为JavaScript会将操作数转换为数字。这个表达式的值是数字15，而不是字符串“15”。
* 左值(lvalue)是一个古老的术语，它是指“表达式只能出现在赋值运算符的左侧”。在javascript中，变量、对象属性和数组元素均是左值。
* 表4-1：javascript运算符![javascript-operator.png](./images/javascript-operator.png)
* 需要注意的是，属性访问表达式和调用表达式的优先级要比表4-1中列出的所有运算符都要高。`typeof my.functions[x](y)`
* 运算
```
true+true = > 2
2 + null => 2
2 + undefined => NaN
1 + 2 + " blind mice" => "3 blind mice"
1 + (2+" blind mice") => "12 blind mice"
0===-0 =>true
NaN !== NaN =>true
"11" < "3"=>true
"11" < 3 =>false
```
* 递增“++”运算符的返回值依赖于它相对于操作数的位置。当运算符在操作数之前，称为“前增量运算符”(pre-increment operator)，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后，称为“后增量运算符”(post-increment operator)，它对操作数进行增量计算，但返回未做增量(unincrement)计算的值。
* “==”和“===”运算符用于比较两个值是否相等，当然他们对相等的定义不尽相同。“===”也称为严格相等运算符(strict equality operator)，有时也称做恒等运算符(identity operator),它用来检测两个操作数是否严格相等。“==”运算符称做相等运算符(equality operator)，它用来检测两个操作数是否相等，这里的相等的定义非常宽松，可以允许进行类型转换。
* javascript对象的比较是引用的比较，而不是值的比较。对象和其本身是相等的，但和其它任何对象都不相等。如果两个不同的对象具有相同数量的属性，相同的属性名和值，他们依然是不相等的。相应位置的数组是相等的两个数组也是不相等的。
* 对于数字和字符串操作符来说，加号运算符和比较运算符的行为都有所不同，前者更偏爱字符串，如果它的其中一个操作数是字符串的话，则进行字符串链接操作。而比较运算符则更偏爱数字，只有在两个操作数都是字符串的时候，才会进行字符串的比较。
* in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true。
* instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。
* 所有对象都是Object的实例。当通过instanceof判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”的检测。如果instanceof的左操作数不是对象的话，instanceof返回false。如果右侧操作数不是函数，则抛出一个类型错误异常。
* "!"运算符是一元运算符。它放置在一个单独的操作数之前。它的目的是将操作数的布尔值进行求反。可以通过使用两次逻辑非运算符来得到一个值的等价布尔值：!!x
* 赋值操作符的结合性是从右至左，也就是说，如果一个表达中出现了多个赋值运算符，运算顺序是从右到左。因此可以通过`i=j=k=0`来对多个变量赋值。
* delete希望他的操作数是一个左值，如果它不是左值，那么delete将不进行任何操作同时返回true。否则，delete将试图删除这个指定的左值。如果删除成功，delete将返回true。然而并不是所有的属性都可以删除，一些内置的核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。
* void是一元运算符，它出现在操作数之前，操作数可以是任意类型。这个操作数并不是经常使用，操作数会照常计算，但忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具意义。
* 逗号运算符是二元运算符，他的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。

# 语句
* 可以用逗号运算符将几个表达式连接在一起，形成一个表达式，同样，javascript中还可以将多条语句联合在一起，形成一条复合语句。只须用花括号将多条语句括起来即可。
* 关于语句块有几点需要注意，第一，语句块的结尾不需要分号。块中的原始语句必须以分号结束，但语句块不需要。第二，语句块中的行都有缩进，这不是必需的，但整齐的缩进能让代码可读性更强，更容易理解。最后，需要注意，JavaScript中没有块级作用域，在语句块中声明的变量并不是语句块私有的。
* 全局变量是全局对象的属性。然而和其它全局对象属性不同的是，var声明的变量是无法通过delete删除的。
* 变量在声明他们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本或者函数的顶部。但是初始化的操作则还在原来var语句的位置执行，在声明语句之前变量的值是undefined。
* if语句在程序执行过程中创建一条分支，并且可以使用else if来处理多条分支。然而，当所有的分支都依赖于同一个表达式的值时，else if并不是最佳解决方案。在这种情况下，重复计算多条if语句中的条件表达式是非常浪费的做法。switch语句正适合处理这种情况。关键字switch之后紧跟着圆括号括起来的一个表达式，随后是一对花括号括起来的代码块。
* switch语句代码块中可以使用多个case关键字标识的代码片段，case之后是一个表达式和一个冒号，case和标记语句很类似，只是这个标记语句并没有名字，它只和它后面的表达式关联在一起。当执行这条switch语句的时候，他首先计算expression的值，然后查找case子句中的表达式是否和expression的值相同，这里的相同是按照“===”运算符比较的。如果找到匹配的case，那么将会执行这个case对应的代码块。如果找不到匹配的case，那么将会执行“default：”标签中的代码块。如果没有“default：”标签，switch语句将跳过它的所有代码块。
```
switch(n){
	case 1:
	//code
	break;
	case 2:
	//code
	break;
	case 3:
	//code
	break;
	default:
	//code
	break;
}
```
* 需要注意的是，在上面的代码中，在每一个case语句块的结尾处都使用了关键字break。break语句可以是解释器跳出switch语句货循环语句。在switch语句中，case只是指明了要执行的代码起点，但并没有指明终点。如果没有break语句，那么switch语句就会从与expression的值相匹配的case标签处的代码块开始执行，依次执行后续的语句，一直到整个switch代码块的结尾。这种由一个case标签执行到下一个case标签的代码逻辑是很少使用的，在大多数情况下，应该使用break语句来终止每个case语句块。
* 我们注意到，在之前的例子中，“default：”标签都出现在switch的末尾，位于所有case标签之后。当然这是最合理也是最常用的写法，实际上，“default：”标签可以放置在switch语句内的任何地方。
* 在do/while循环和普通的while循环之间有两点语法方面的不同之处。首先，do循环要求必须使用关键字do来标识循环的开始，用while来标识循环的结尾并进入循环条件判断；其次，和while循环不同，do循环是用分号结尾的。如果whil的循环体使用花括号括起来的话，则while循环也不用使用分号做结尾。
* 需要注意的是，只要for/in循环中variable的值可以当做赋值表达式的左值，它可以是任意表达式。每次循环都会计算这个表达式，也就是说每次循环它计算的值有可能不同。
```
var o={x:1,y:2,z:3};
var a=[],i=0;
for(a[i++] in o)/*empty*/
```
* break和continue是javascript中唯一可以使用语句标签的语句。
* 单独使用break语句的作用是立即退出最内层的循环货switch语句。
* 不管continue语句带不带标签，它只能在循环体内使用。在其它地方使用将会报语法错误。